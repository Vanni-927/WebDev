 <!--CSS priority Order (Cascade Order):
Inline styles (e.g. <div style="color: red;">)
Internal styles (within <style> tags in the <head>)
External stylesheets (<link rel="stylesheet" href="style.css">)
Within any one source (e.g. internal or external), the order is:
Specificity — more specific selectors override less specific ones
Order of appearance — if specificity is equal, the last rule written wins
inline-block lets you:
Place elements next to each other (like inline)
Style them fully (like block — width, height, margin, padding)








BOX SHADOW-
The shadow should have the following properties:
Horizontal offset of 10px.
Vertical offset of 10px.
Blur radius of 15px.
Shadow color should be gray.

In HTML, comment in done using <--
In CSS, comments are done using /* comment here */
In JavaScript, comments are done using // for single line and /* comment here */ for multi-line.
In JSX, {/* */}


[] this denotes arrary
{} this denotes object

















JAVASCRIPT

Firstly a code file is there, then parse [tokenisation process that is take up the specific keywords], and then make up a syntax tree.
                                                        ||
then we have JIT Just In Time compilation
converts byte code to machine code
, which is a process that compiles the code at runtime, so it can be executed faster.
Then we have the execution phase, where the code is executed by the JavaScript engine.





js is a oop language but prototype based, not class based.
i.e. it uses prototypes to create objects and inheritance, rather than classes.
In class based, we make blueprints known of objects, so the new object made has the same properties and methods as the blueprint but is independent of the blueprint. So therefore, an abstract object is made.
In prototype based , we clone the objects i.e. Object can still refer back to original. So therefore a real object is made.


Conclusion is that js is oop b/c it used the keywords of it but dont really follow the principles of it.
Behind the scenes, it is everytime  prototype based, but it just has the syntax of class based.







/*use of EVENT DELEGATION- event bubbles from child elements to their parent.
key difference btw EVENT DELEGATION and DIRECT BINDING
in direct binding, we will add event listener to btn but then we need to have a loop for every btn
here in this case we are just adding eventlis. to parent only and every child will have the function by itself automatically using event.target.
*/

its like giving every waiter a phone
or
putting up a speaker in the kitchen itself.

